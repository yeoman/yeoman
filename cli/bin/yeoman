#!/usr/bin/env node
var fs = require('fs'),
  join = require('path').join,
  help = join(__dirname, 'help.txt'),
  mkdirp = require('mkdirp'),
  pkg = require('../package.json'),
  rl = require('readline'),
  spawn = require('child_process').spawn;

// Returns the user's home directory in a platform agnostic way.
function getUserHome() {
  return process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'];
}

// grunt with the plugin registered
var grunt = require('grunt').npmTasks(join(__dirname, '../'));

// Get back a reference to the internal grunt cli object (Yes, it's hacky) We
// need this to be able to read grunt command line parsed options and tasks to
// run to hook our internal additional logic.
//
// Another (nicer) alternative is to redo the command line parsing with nopt,
// but it'll add yet another dependency for a very little thing
var cli =  require('grunt/lib/grunt/cli');

// command line options and remaining args
var opts = cli.options,
  cmds = cli.tasks,
  route = cmds.join(' ').trim('');

// custom help, on `h5bp help`
if(/^help/.test(route)) {
  if(/^help$/.test(route)) return fs.createReadStream(help).pipe(process.stdout);
  cli.tasks = cmds.join(':');
}

// add the plugin version on `--version`
if(opts.version) {
  console.log('h5bp  v%s', pkg.version);
}

// `yeoman init` -> `grunt init:yeoman`
if(/^init$/.test(route)) {
  cli.tasks = 'init:yeoman';
}

// a nest command?
if(/^install|uninstall|search|update/.test(route)) {
  cli.tasks = 'nest' + ':' + cmds.join(':');
}

/* Yeoman Insight =========================================================== */

// Store global state used throughout the project in the user's home dir.
// e.g. /Users/username/.yeoman
var YEOMAN_DIR = join(getUserHome(), '.' + pkg.name);

var insightFolder = join(YEOMAN_DIR, 'insight');

// Assume yeomaninsight.py is installed in the user's home dir.
var insightRecordCmd = [join(insightFolder, 'yeomaninsight.py'), 'record'];

// Record this action in Insight (e.g. python yeomaninsight.py record cmd cmd2).
var insight = spawn('python', insightRecordCmd.concat(cmds));
//insight.stdout.pipe(process.stdout);

fs.stat(join(insightFolder, '.log'), function(err, stats) {
  // Error means file doesn't exist and this is the first run.
  // Go through stat opt-in flow.
  if (err) {
    var msg = "==========================================================================\n\
We're constantly looking for ways to make " + pkg.name + " better!\n\
May we anonymously report usage statistics to improve the tool over time?\n\
More info: XXX\n\
==========================================================================\n\
[Y/n]: ";

    // TODO: Bug where backspace re-prompts.
    var i = rl.createInterface(process.stdin, process.stdout, null);
    i.question(msg, function(answer) {
      if (!(answer == '' || answer.toUpperCase() == 'Y')) {
        var insight = spawn('python', insightRecordCmd.concat(['NO_STATS']));
      }
      i.close();
      process.stdin.destroy();
    });
  }
});
/* ========================================================================== */

// if the route is empty
if(/^$/.test(route)) {
  // this is specific to an empty route code
  console.log(pkg.name + ' v%s', pkg.version);

  // we return early to prevent grunt from actually running
  // and instead just output help.txt
  return fs.createReadStream(help).pipe(process.stdout);
}

// the grunt cli
grunt.cli();
